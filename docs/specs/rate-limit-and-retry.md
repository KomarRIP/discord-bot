## RateLimitQueue / Retry / Дедупликация Discord операций

Цель: обеспечить **безопасное** и **предсказуемое** выполнение операций Discord API:

- не превышать лимиты (route + global),
- корректно повторять временные сбои,
- исключить дубли при повторном запуске деплоя,
- сохранять прогресс (resume) и давать читаемый лог.

Этот документ описывает инфраструктурный механизм, который используют `DiscordGateway` и use‑case деплоя.

---

## 1. Проблема, которую решаем

Discord API может:
- возвращать `429` (rate limit),
- падать временно (network/5xx),
- отказывать по правам (403),
- быть недетерминированным при повторе **create** (создаст дубликат).

Требование проекта: **идемпотентный setup** без дубликатов при retry. Значит, одного «просто ретрая» недостаточно — нужна стратегия **дедупликации и восстановления после краша**.

---

## 2. Определения

- **Operation**: одна атомарная Discord‑операция (создать роль, обновить канал, заменить overwrites, отправить сообщение).
- **IdempotencyKey**: стабильный ключ операции, позволяющий распознавать «та же самая операция» при повторе.
- **StepJournal**: журнал шагов деплоя (intent/result), который позволяет продолжить после сбоя.

---

## 3. Контракт очереди (инфраструктура)

Очередь предоставляет API уровня:

- `enqueue(operation) -> Promise<OperationResult>`
- гарантирует:
  - ограничение параллелизма,
  - backoff при `RateLimited/Transient`,
  - детерминированный порядок внутри одного `guildId`,
  - дедупликацию одинаковых операций по `IdempotencyKey` (в рамках «окна времени»).

Примечание: это **не** бизнес‑логика. Queue не решает «нужно ли создавать роль» — это решает `TemplateDeploymentService`. Queue решает «как безопасно выполнить».

---

## 4. Модель Operation

Минимальные поля (концептуально):

- `operationId`: уникальный (для логов/трассировки)
- `guildId`
- `kind`: `RoleEnsure | ChannelEnsure | OverwritesReplace | MessageEnsure | Read`
- `idempotencyKey`: строка вида  
  `guild:<guildId>/deploy:<deploymentId>/<kind>/<objectKey>/<fingerprint>`
- `attempt`: номер попытки
- `budget`:
  - `deadlineAt` (общий таймаут)
  - `maxAttempts` (например 8)
- `execute`: функция, вызывающая Discord REST (через SDK) и возвращающая результат
- `classifyError(e)`: перевод ошибки SDK в типизированную ошибку

---

## 5. Параллелизм и порядок

### 5.1. Внутри одного guild

Операции одного `guildId` выполняются **строго последовательно**.

Причины:
- меньше конфликтов (особенно role/channel create),
- проще воспроизводимость и логирование,
- проще reasoning при безопасности прав.

### 5.2. Между guild

Можно выполнять параллельно (например, до N=3), но:
- общий глобальный лимит Discord всё равно может ударить,
- в MVP допускаем **низкий параллелизм** и простую конфигурацию.

---

## 6. Retry/backoff политика

### 6.1. Ошибки без retry

- `ValidationError` (ошибочная конфигурация/ввод)
- `Forbidden` (нет прав бота)
- `NotFound` (логическая ошибка плана — например, попытка обновить канал по id, которого нет; обычно лечится пересборкой плана, а не ретраем операции)

### 6.2. Ошибки с retry

- `RateLimited` (HTTP 429):
  - ждать `retry_after` (если есть), иначе backoff
- `Transient` (network/5xx/timeouts):
  - экспоненциальный backoff + jitter
- `Conflict` (состояние изменилось):
  - не ретраим «в лоб», а инициируем пересборку плана (уровнем выше), если это возможно

Рекомендуемый backoff (пример):
- base: 500ms
- max: 20s
- jitter: ±30%

---

## 7. Исключение дублей при create (ключевой раздел)

Проблема: если процесс упал **после create**, но **до сохранения mapping**, следующий деплой не увидит mapping и попробует создать заново.

### 7.1. Стратегия MVP: Managed Names + Adoption

Для всех bot‑managed объектов вводим детерминированный шаблон имени:

- **Role managed name**:  
  `〚SSO〛 <DisplayName> 〔<RoleKey>〕`
- **Channel managed name** (Discord ограничивает формат, но ключ можно встроить):  
  `<slug>-<shortkey>` (например `priemnaya-intake`, где `intake` — стабильный суффикс)
- **Category managed name**:  
  `〚SSO〛 <DisplayName> 〔<CategoryKey>〕`

Принцип: наличие `〔<Key>〕` позволяет **точно** найти «наш» объект по имени, если mapping потерян.

### 7.2. Adoption (усыновление объекта)

Перед `create` делаем попытку «adopt»:

1) поиск объекта по managed name (и типу);
2) если найден ровно один:
   - создаём mapping `(kind,key)->discordId`,
   - продолжаем как `update/skip` по fingerprint.
3) если найдено несколько:
   - считаем это `Conflict` и останавливаем деплой с инструкцией «удалите дубликаты или переименуйте».

### 7.3. Компромисс и безопасность

Риск: пользователь может создать объект с таким именем вручную. Снижаем риск:
- используем нестандартный префикс `〚SSO〛` и ключ в скобках,
- в документации и UI явно пишем: «не переименовывайте управляемые элементы».

Фаза 2: можно усилить механизм через «канал‑маркер» и/или отдельный реестр, но для ролей Discord не даёт описаний, поэтому имя остаётся главным маркером.

---

## 8. StepJournal (прогресс деплоя)

Чтобы деплой был resume‑friendly, фиксируем журнал шагов:

- `DeploymentStepPlanned` (intent): kind/key/fingerprint
- `DeploymentStepApplied` (result): created/updated/skipped + discordId
- `DeploymentStepFailed` (error)

Хранение:
- минимум в БД (таблица `deployment_steps`), опционально дублируем в audit‑канал.

Использование:
- при повторном запуске деплоя:
  - пересобираем план,
  - шаги, которые уже `Applied` с тем же fingerprint, считаем `skip`.

---

## 9. Наблюдаемость (MVP)

Каждая операция логируется с полями:
- `requestId`, `deploymentId`, `operationId`
- `guildId`, `kind`, `key`, `fingerprint`
- `attempt`, `durationMs`, `result`

Это нужно, чтобы диагностировать rate limit и ошибки прав без гадания.

